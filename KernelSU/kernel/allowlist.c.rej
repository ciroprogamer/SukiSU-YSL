--- kernel/allowlist.c
+++ kernel/allowlist.c
@@ -92,7 +92,7 @@ static uint8_t allow_list_bitmap[PAGE_SIZE] __read_mostly __aligned(PAGE_SIZE);
 static struct work_struct ksu_save_work;
 static struct work_struct ksu_load_work;
 
-static bool persistent_allow_list(void);
+bool persistent_allow_list(void);
 
 void ksu_show_allow_list(void)
 {
@@ -267,7 +267,7 @@ bool __ksu_is_allow_uid(uid_t uid)
 
 	if (unlikely(uid == 0)) {
 		// already root, but only allow our domain.
-		return ksu_is_ksu_domain();
+		return is_ksu_domain();
 	}
 
 	if (forbid_system_uid(uid)) {
@@ -352,7 +352,7 @@ bool ksu_get_allow_list(int *array, int *length, bool allow)
 	return true;
 }
 
-static void do_save_allow_list(struct work_struct *work)
+void do_save_allow_list(struct work_struct *work)
 {
 	u32 magic = FILE_MAGIC;
 	u32 version = FILE_FORMAT_VERSION;
@@ -394,7 +394,7 @@ exit:
 	filp_close(fp, 0);
 }
 
-static void do_load_allow_list(struct work_struct *work)
+void do_load_allow_list(struct work_struct *work)
 {
 	loff_t off = 0;
 	ssize_t ret = 0;
@@ -484,7 +484,7 @@ void ksu_prune_allowlist(bool (*is_uid_valid)(uid_t, char *, void *), void *data
 }
 
 // make sure allow list works cross boot
-static bool persistent_allow_list(void)
+bool persistent_allow_list(void)
 {
 	return ksu_queue_work(&ksu_save_work);
 }
